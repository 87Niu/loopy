// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Save.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include <iostream>
#include <fstream>
#include <ctime>
#include <sstream>
#include <iomanip> 

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::save_service;
std::string getCurrentDateTime() {
    // 获取当前时间
    std::time_t now = std::time(nullptr);

    // 将时间转换为本地时间结构
    std::tm* localTime = std::localtime(&now);

    // 创建一个字符串流对象，用于构建日期和时间的字符串
    std::ostringstream oss;

    // 构建日期和时间的字符串，格式为 YYYYMMDD_HHMMSS
    oss << (localTime->tm_year + 1900)
        << std::setw(2) << std::setfill('0') << (localTime->tm_mon + 1)
        << std::setw(2) << std::setfill('0') << localTime->tm_mday;

    return oss.str();
}


std::string getTimeNow() {
    // 获取当前时间
    std::time_t now = std::time(nullptr);

    // 将时间转换为本地时间
    std::tm* localTime = std::localtime(&now);

    // 创建一个字符串流
    std::ostringstream oss;

    // 使用字符串流格式化日期和时间
    oss << std::setw(4) << std::setfill('0') << (localTime->tm_year + 1900) << '-'
        << std::setw(2) << std::setfill('0') << (localTime->tm_mon + 1) << '-'
        << std::setw(2) << std::setfill('0') << localTime->tm_mday << ' '
        << std::setw(2) << std::setfill('0') << localTime->tm_hour << ':'
        << std::setw(2) << std::setfill('0') << localTime->tm_min << ':'
        << std::setw(2) << std::setfill('0') << localTime->tm_sec;

    // 返回格式化的日期时间字符串
    return oss.str();
}





class SaveHandler : virtual public SaveIf {
 public:
  SaveHandler() {
    // Your initialization goes here
  }

  int32_t save_data(const std::string& username, const std::string& password, const  ::match_service::User& user1, const  ::match_service::User& user2) {
    // Your implementation goes here
    std::cout << std::endl;
    std::cout << "user_id: " << user1.id << "  " <<  "user_name: " << user1.name << "  " << "user_score: " << user1.score << std::endl;
    std::cout << "user_id: " << user2.id << "  " <<  "user_name: " << user2.name << "  " << "user_score: " << user2.score << std::endl;


    // 固定文件夹路径
    std::string folderPath = "../../../data/";

    // 构建文件名
    std::string filename = folderPath + getCurrentDateTime() + ".txt";

    // 创建文件
    std::ofstream file(filename, std::ios::app);

    if (file.is_open()) {
        file << getTimeNow() << std::endl;
        file << "   " << "user_id: " << user1.id << "  " <<  "user_name: " << user1.name << "  " << "user_score: " << user1.score << std::endl;
        file << "   " << "user_id: " << user2.id << "  " <<  "user_name: " << user2.name << "  " << "user_score: " << user2.score << std::endl;
        file << std::endl;
        file.close();  // 关闭文件流
        std::cout << "Data saved successfully to " << filename << std::endl;
    } else {
        std::cerr << "Error opening file: " << filename << std::endl;
    }




    return 0;
  }

};

int main(int argc, char **argv) {
  int port = 8000;
  ::std::shared_ptr<SaveHandler> handler(new SaveHandler());
  ::std::shared_ptr<TProcessor> processor(new SaveProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  std::cout << "Start Save Result: " << std::endl;
  server.serve();
  return 0;
}

